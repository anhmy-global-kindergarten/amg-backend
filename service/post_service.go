package service

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"github.com/google/uuid"
	"golang.org/x/net/html"
	"log"
	"net/http"
	"os"
	"strings"
)

func ProcessContentImages(content string, baseURL string) (string, error) {
	doc, err := html.Parse(strings.NewReader(content))
	if err != nil {
		return "", err
	}

	var f func(*html.Node)
	f = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "img" {
			// Iterate over all attributes of the <img> tag
			for i, attr := range n.Attr {
				if attr.Key == "src" && strings.HasPrefix(attr.Val, "data:image/") {
					// 1. Extract base64 data
					parts := strings.Split(attr.Val, ";base64,")
					if len(parts) != 2 {
						continue // Not a valid base64 image
					}

					mimeType := strings.TrimPrefix(parts[0], "data:")
					imageData, err := base64.StdEncoding.DecodeString(parts[1])
					if err != nil {
						log.Printf("Error decoding base64 image: %v", err)
						continue
					}

					// 2. Determine file extension
					ext, ok := mimeTypeToExt(mimeType)
					if !ok {
						log.Printf("Unsupported MIME type: %s", mimeType)
						continue
					}

					// 3. Save the file with a unique name
					uniqueFilename := fmt.Sprintf("%s.%s", uuid.New().String(), ext)
					savePath := fmt.Sprintf("./uploads/%s", uniqueFilename)

					err = saveBytesToFile(imageData, savePath)
					if err != nil {
						log.Printf("Error saving image file: %v", err)
						continue
					}

					// 4. Replace the src attribute with the new URL
					newURL := fmt.Sprintf("%s/uploads/%s", baseURL, uniqueFilename)
					n.Attr[i].Val = newURL
				}
			}
		}
		// Recursively process child nodes
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			f(c)
		}
	}
	f(doc)

	// Render the modified HTML back to a string
	var buf bytes.Buffer
	if err := html.Render(&buf, doc); err != nil {
		return "", err
	}
	// html.Render wraps the content in <html><body>...</body></html>
	// We need to extract just our content back out.
	bodyContent, err := extractBodyContent(buf.String())
	if err != nil {
		return "", err
	}

	return bodyContent, nil
}

// Helper to get extension from MIME type
func mimeTypeToExt(mimeType string) (string, bool) {
	switch mimeType {
	case "image/jpeg":
		return "jpg", true
	case "image/png":
		return "png", true
	case "image/gif":
		return "gif", true
	case "image/webp":
		return "webp", true
	default:
		return "", false
	}
}

// Helper to save a byte array to a file
func saveBytesToFile(data []byte, path string) error {
	file := http.DetectContentType(data)
	// Simple check, you might want a more robust one
	if !strings.HasPrefix(file, "image/") {
		return fmt.Errorf("invalid file type: %s", file)
	}

	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.Write(data)
	return err
}

// Helper to extract content from <body> tag generated by html.Render
func extractBodyContent(fullHTML string) (string, error) {
	doc, err := html.Parse(strings.NewReader(fullHTML))
	if err != nil {
		return "", err
	}

	var bodyNode *html.Node
	var findBody func(*html.Node)
	findBody = func(n *html.Node) {
		if n.Type == html.ElementNode && n.Data == "body" {
			bodyNode = n
			return
		}
		for c := n.FirstChild; c != nil && bodyNode == nil; c = c.NextSibling {
			findBody(c)
		}
	}
	findBody(doc)

	if bodyNode == nil {
		return "", fmt.Errorf("<body> tag not found")
	}

	var buf bytes.Buffer
	for c := bodyNode.FirstChild; c != nil; c = c.NextSibling {
		if err := html.Render(&buf, c); err != nil {
			return "", err
		}
	}
	return buf.String(), nil
}
